name: teof-ci

on:
  push:
    paths:
      - 'capsule/**'
      - 'governance/**'
      - 'cli/**'
      - 'teof/**'
      - 'scripts/**'
      - 'docs/**'
      - '.github/workflows/**'
  pull_request:
    paths:
      - 'capsule/**'
      - 'governance/**'
      - 'cli/**'
      - 'teof/**'
      - 'scripts/**'
      - 'docs/**'
      - '.github/workflows/**'

permissions:
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  STRICT_CAPSULE: 'true'       # fail if no capsule baseline
  STRICT_GOVERNANCE: 'false'   # anchors warn-only by default; set 'true' to enforce

jobs:
  show-tree:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with: { fetch-depth: 0 }
      - name: Show repo tree
        run: |
          if ! command -v tree >/dev/null 2>&1; then
            sudo apt-get update -y >/dev/null 2>&1 || true
            sudo apt-get install -y tree >/dev/null 2>&1 || true
          fi
          tree -a -L 2 || true

  verify:
    runs-on: ubuntu-latest
    needs: show-tree
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Cache pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/pyproject.toml', '**/requirements*.txt') }}
          restore-keys: ${{ runner.os }}-pip-

      - name: Install package
        run: |
          python -m pip install --upgrade pip
          pip install -e .

      # ---- Make-free repo health (run with bash) ----
      - name: Repo health
        shell: bash
        run: |
          set -euo pipefail
          chmod +x tools/bootstrap.sh tools/doctor.sh 2>/dev/null || true
          # bootstrap is non-blocking; doctor is authoritative
          if ! bash tools/bootstrap.sh; then
            echo "::warning::bootstrap reported an issue (non-blocking)"; 
          fi
          bash tools/doctor.sh

      - name: Smoke test bootloader CLI (non-blocking)
        shell: bash
        run: |
          set +e
          python teof/bootloader.py --help > bootloader-help.log 2>&1
          status=$?
          if [ $status -ne 0 ]; then
            echo "::warning::bootloader help failed (status $status)"
            cat bootloader-help.log || true
          fi
          rm -f bootloader-help.log
          exit 0

      # ---- Capsule baseline detection/verification ----
      - name: Detect capsule baseline
        id: detect
        shell: bash
        run: |
          set -euo pipefail
          CAP_ROOT="capsule"
          CUR="$CAP_ROOT/current"
          if [ -f "$CUR/hashes.json" ]; then
            echo "baseline_dir=$CUR" >> "$GITHUB_OUTPUT"
            echo "baseline_json=$CUR/hashes.json" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          if compgen -G "$CAP_ROOT/v*/hashes.json" >/dev/null; then
            latest="$(ls -1d "$CAP_ROOT"/v*/ | sort -V | tail -n1)"; latest="${latest%/}"
            mkdir -p "$CUR"
            cp -a "$latest"/. "$CUR"/
            if [ ! -f "$CUR/hashes.json" ] || [ ! -f "$CUR/capsule.txt" ]; then
              echo "::error file=$CUR::expected hashes.json and capsule.txt after materialization"
              exit 1
            fi
            echo "baseline_dir=$CUR" >> "$GITHUB_OUTPUT"
            echo "baseline_json=$CUR/hashes.json" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          if [ "${STRICT_CAPSULE}" = "true" ]; then
            echo "::error::No capsule baseline found and STRICT_CAPSULE=true"
            exit 1
          else
            echo "::warning::No capsule baseline found; STRICT_CAPSULE=false so skipping capsule verification"
            echo "baseline_dir=" >> "$GITHUB_OUTPUT"
            echo "baseline_json=" >> "$GITHUB_OUTPUT"
            exit 0
          fi

      - name: Verify capsule hashes
        if: ${{ steps.detect.outputs.baseline_json != '' }}
        shell: bash
        env:
          BASE_DIR: ${{ steps.detect.outputs.baseline_dir }}
          HFILE:    ${{ steps.detect.outputs.baseline_json }}
        run: |
          set -euo pipefail
          python - <<'PY'
          import os, json, hashlib, sys
          base_dir = os.environ["BASE_DIR"]; hfile = os.environ["HFILE"]
          def sha256_file(p):
              h = hashlib.sha256()
              with open(p,'rb') as f:
                  for chunk in iter(lambda: f.read(8192), b''):
                      h.update(chunk)
              return h.hexdigest()

          with open(hfile, 'r', encoding='utf-8') as f:
              data = json.load(f)

          manifest = {}
          expected_count = None
          manifest_root = None

          if isinstance(data, dict) and isinstance(data.get('files'), list):
              for item in data['files']:
                  if not isinstance(item, dict):
                      continue
                  rel = item.get('path')
                  sha = item.get('sha256') or item.get('sha')
                  if not rel or not sha:
                      continue
                  manifest[rel] = sha
              expected_count = data.get('count') if isinstance(data.get('count'), int) else None
              manifest_root = data.get('root') if isinstance(data.get('root'), str) else None
          elif isinstance(data, dict):
              manifest = {k: v for k, v in data.items() if isinstance(v, str) and k not in {'root', 'count', 'files'}}
              if 'count' in data and isinstance(data['count'], int):
                  expected_count = data['count']
              if 'root' in data and isinstance(data['root'], str):
                  manifest_root = data['root']
          else:
              print('::error::Unsupported hashes.json format');
              sys.exit(1)

          if expected_count is not None and expected_count != len(manifest):
              print(f"::error file={hfile}::count mismatch expected={expected_count} got={len(manifest)}")
              sys.exit(1)

          ok = True
          for rel, exp in sorted(manifest.items()):
              p = os.path.join(base_dir, rel)
              if not os.path.isfile(p):
                  print(f"::error file={p}::missing file listed in hashes.json"); ok = False; continue
              got = sha256_file(p)
              if got != exp:
                  print(f"::error file={p}::sha256 mismatch expected={exp} got={got}"); ok = False
              else:
                  print(f"OK {rel}")

          if ok and manifest_root:
              print(f"capsule root: {manifest_root}")

          sys.exit(0 if ok else 1)
          PY

      # ---- Governance anchors: warn by default ----
      - name: Validate anchors (warn by default)
        shell: bash
        env:
          STRICT_GOVERNANCE: ${{ env.STRICT_GOVERNANCE }}
          HFILE:             ${{ steps.detect.outputs.baseline_json }}
          ANCHORS_PATH:      governance/anchors.json
        run: |
          set -euo pipefail
          STRICT="${STRICT_GOVERNANCE:-false}"; P="${ANCHORS_PATH}"
          if [ ! -f "$P" ]; then
            if [ "$STRICT" = "true" ]; then
              echo "::error::$P missing and STRICT_GOVERNANCE=true"; exit 1
            else
              echo "::warning::$P not found (warn-only)"; exit 0
            fi
          fi
          python - <<'PY'
          import json, hashlib, os, sys, subprocess
          strict = os.environ.get("STRICT_GOVERNANCE","false") == "true"
          p = os.environ["ANCHORS_PATH"]
          def sha256(b): import hashlib; h=hashlib.sha256(); h.update(b); return h.hexdigest()
          cur = open(p,'rb').read()
          data = json.loads(cur.decode('utf-8'))
          cur_sha = sha256(cur)
          errs = []
          for k in ['version','policy','anchors','immutable_scope','events','releases']:
            if k not in data: errs.append(f"missing key: {k}")
          if data.get('policy') != 'append-only':
            errs.append("policy must be 'append-only'")
          revs = subprocess.check_output(['git','rev-list','-n','2','HEAD','--',p], text=True).splitlines()
          if len(revs) >= 2:
            prev = revs[1]
            prev_bytes = subprocess.check_output(['git','show', f'{prev}:{p}'])
            prev_sha = sha256(prev_bytes)
            if prev_sha != cur_sha:
              last = (data.get('events') or [])[-1] if data.get('events') else None
              if not last or last.get('prev_content_hash') != prev_sha:
                errs.append("append-only violation: last event prev_content_hash mismatch")
          hfile = os.environ.get("HFILE","")
          if hfile and os.path.isfile(hfile):
            basekeys = set(json.load(open(hfile,'r',encoding='utf-8')).keys())
            missing = [m for m in (data.get('immutable_scope') or []) if m not in basekeys]
            if missing: errs.append("immutable_scope not in capsule baseline: " + ", ".join(missing))
          if errs:
            for e in errs:
              print(("::error::" if strict else "::warning::") + e)
            sys.exit(1 if strict else 0)
          else:
            print(f"anchors sha256={cur_sha}  path={p}")
          PY

      # ---- Safety checks for stray files/paths ----
      - name: Check for macOS .DS_Store
        run: |
          if git ls-files | grep -q '\.DS_Store'; then
            echo "::error::.DS_Store files committed"; exit 1
          fi

      - name: Forbid deprecated rings/ path
        run: |
          if git ls-files | grep -q '^rings/'; then
            echo "::error::deprecated path rings/ detected; use governance/"; exit 1
          fi

      - name: Forbid legacy brief output path
        run: |
          if git ls-files | grep -q '^branches_thick/ocers_out/'; then
            echo "::error::legacy path branches_thick/ocers_out/ is forbidden"; exit 1
          fi

      # ---- Build brief (no make) ----
      - name: Build brief (direct, no make)
        run: |
          set -euo pipefail
          mkdir -p artifacts/ocers_out
          OUT_ROOT="$GITHUB_WORKSPACE/artifacts" python -m teof.cli brief
          test -f artifacts/ocers_out/latest/brief.json
          test -f artifacts/ocers_out/latest/score.txt
          ls -l artifacts/ocers_out/latest/

      - name: Upload brief artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ocers_out
          path: artifacts/ocers_out/latest/
          if-no-files-found: warn
          retention-days: 7

  planner-eval:
    runs-on: ubuntu-latest
    needs: verify
    if: always()
    continue-on-error: true
    env:
      PYTHONPATH: ${{ github.workspace }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install package
        run: |
          python -m pip install --upgrade pip
          pip install -e .
          pip install pytest

      - name: Planner receipt run (non-blocking)
        run: |
          python3 tools/planner/eval_minimal.py

      - name: Upload planner receipts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: planner-receipts
          path: _report/planner/
          if-no-files-found: warn
          retention-days: 7
