name: teof-ci

on:
  push:
    paths:
      - 'capsule/**'
      - 'governance/**'
      - 'cli/**'
      - 'scripts/**'
      - 'Makefile'
      - '.github/workflows/**'
  pull_request:
    paths:
      - 'capsule/**'
      - 'governance/**'
      - 'cli/**'
      - 'scripts/**'
      - 'Makefile'
      - '.github/workflows/**'

permissions:
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  show-tree:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Show repo tree
        run: |
          if ! command -v tree >/dev/null 2>&1; then
            sudo apt-get update -y >/dev/null 2>&1 || true
            sudo apt-get install -y tree >/dev/null 2>&1 || true
          fi
          echo "Top-level:"
          tree -a -L 2 || true
          echo "Capsule subtree:"
          tree -a -L 2 capsule || true

  verify:
    runs-on: ubuntu-latest
    needs: show-tree
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      # Prefer capsule/current/hashes.json; else use latest capsule/vX.Y/hashes.json.
      # If only vX.Y exists, materialize current/ from that version for this run.
      - name: Detect capsule baseline (and materialize current if needed)
        id: detect
        shell: bash
        run: |
          set -euo pipefail
          CAP_ROOT="capsule"
          CUR="$CAP_ROOT/current"

          # 1) Prefer current/ if it already has hashes.json
          if [ -f "$CUR/hashes.json" ]; then
            echo "Using baseline: $CUR/hashes.json"
            echo "baseline_dir=$CUR" >> "$GITHUB_OUTPUT"
            echo "baseline_json=$CUR/hashes.json" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # 2) Otherwise look for latest versioned v*/hashes.json
          if compgen -G "$CAP_ROOT/v*/hashes.json" >/dev/null; then
            latest="$(ls -1d "$CAP_ROOT"/v*/ | sort -V | tail -n1)"
            latest="${latest%/}"
            echo "Materializing current/ from: $latest"
            mkdir -p "$CUR"
            cp -a "$latest"/. "$CUR"/
            # Sanity: both hashes.json and capsule.txt should be present
            if [ ! -f "$CUR/hashes.json" ] || [ ! -f "$CUR/capsule.txt" ]; then
              echo "::error file=$CUR::materialization failed: expected hashes.json and capsule.txt"
              exit 1
            fi
            echo "baseline_dir=$CUR" >> "$GITHUB_OUTPUT"
            echo "baseline_json=$CUR/hashes.json" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "::error::No capsule baseline found. Expected either capsule/current/hashes.json or a versioned capsule/vX.Y/hashes.json"
          exit 1

      - name: Verify capsule hashes
        shell: bash
        env:
          BASE_DIR: ${{ steps.detect.outputs.baseline_dir }}
          HFILE:    ${{ steps.detect.outputs.baseline_json }}
        run: |
          set -euo pipefail
          echo "Baseline dir:  $BASE_DIR"
          echo "Baseline JSON: $HFILE"
          python - <<'PY'
import os, json, hashlib, sys
base_dir = os.environ["BASE_DIR"]
hfile    = os.environ["HFILE"]

with open(hfile, 'r', encoding='utf-8') as f:
    expected = json.load(f)

def sha256_file(p):
    h = hashlib.sha256()
    with open(p,'rb') as f:
        for chunk in iter(lambda: f.read(8192), b''):
            h.update(chunk)
    return h.hexdigest()

ok = True
for rel, exp in expected.items():
    p = os.path.join(base_dir, rel)
    if not os.path.isfile(p):
        print(f"::error file={p}::missing file listed in hashes.json")
        ok = False
        continue
    got = sha256_file(p)
    if got != exp:
        print(f"::error file={p}::sha256 mismatch expected={exp} got={got}")
        ok = False
    else:
        print(f"OK {rel}")
sys.exit(0 if ok else 1)
PY

      - name: Validate anchors (strict governance only: schema + append-only + scope vs baseline)
        shell: bash
        env:
          HFILE:        ${{ steps.detect.outputs.baseline_json }}
          ANCHORS_PATH: governance/anchors.json
        run: |
          set -euo pipefail
          python - <<'PY'
import json, hashlib, os, sys, subprocess

P = os.environ["ANCHORS_PATH"]
if not os.path.isfile(P):
    print(f"Error: {P} not present."); sys.exit(1)

def sha256(b):
    h=hashlib.sha256(); h.update(b); return h.hexdigest()

# Load current anchors
cur_bytes = open(P,'rb').read()
cur_sha   = sha256(cur_bytes)
data      = json.loads(cur_bytes.decode('utf-8'))

# Schema/policy checks
required = ['version','policy','anchors','immutable_scope','events','releases']
missing  = [k for k in required if k not in data]
if missing:
    print("Error: missing keys in anchors:", ", ".join(missing)); sys.exit(1)
if data.get('policy') != 'append-only':
    print("Error: policy must be 'append-only'"); sys.exit(1)

# Determine the previous commit that CHANGED THIS FILE (not just HEAD~1)
rev_list = subprocess.check_output(['git','rev-list','-n','2','HEAD','--',P], text=True).splitlines()
if len(rev_list) < 2:
    print("Append-only check: first change to anchors; nothing to compare"); prev_sha=None
else:
    prev_change = rev_list[1]
    prev_bytes  = subprocess.check_output(['git','show', f'{prev_change}:{P}'])
    prev_sha    = sha256(prev_bytes)

# Append-only: if content changed, last event must carry prev SHA
if prev_sha and prev_sha != cur_sha:
    last = data['events'][-1] if data.get('events') else None
    if not last or last.get('prev_content_hash') != prev_sha:
        print('Error: anchors events not append-only (last.prev_content_hash must equal sha256(previous content)).'); sys.exit(1)
    else:
        print('Append-only check: OK (against previous file change)')
else:
    print('Append-only check: anchors unchanged or first commit for this path')

# Scope vs capsule baseline (must be subset of baseline keys; warn if not exact match)
baseline = json.load(open(os.environ["HFILE"],'r',encoding='utf-8'))
scope = set(data.get('immutable_scope',[]))
basekeys = set(baseline.keys())

missing = [p for p in scope if p not in basekeys]
if missing:
    print('Error: immutable_scope paths missing from baseline hashes.json:')
    for m in missing: print('  -', m)
    sys.exit(1)
if not scope:
    print('Warning: immutable_scope is empty')
elif scope != basekeys:
    extra = sorted(scope - basekeys)
    absent= sorted(basekeys - scope)
    if extra:
        print('Warning: immutable_scope has extra paths not in baseline:', *extra, sep="\n  - ")
    if absent:
        print('Warning: immutable_scope omits baseline paths:', *absent, sep="\n  - ")

print(f'anchors sha256={cur_sha}  path={P}')
PY

      - name: Check for macOS .DS_Store
        run: |
          if git ls-files | grep -q '\.DS_Store'; then
            echo "::error::.DS_Store files committed"; exit 1
          else
            echo "No .DS_Store files found."
          fi

      - name: Forbid deprecated rings/ path
        run: |
          if git ls-files | grep -q '^rings/'; then
            echo "::error::deprecated path rings/ detected; use governance/"; exit 1
          fi

      - name: Forbid legacy brief output path
        run: |
          if git ls-files | grep -q '^branches_thick/ocers_out/'; then
            echo "::error::legacy path branches_thick/ocers_out/ is forbidden"; exit 1
          fi

      - name: Build brief (smoke test)
        shell: bash
        run: |
          set -euo pipefail
          if command -v make >/dev/null 2>&1; then
            make brief
            test -f artifacts/ocers_out/latest/brief.json
            test -f artifacts/ocers_out/latest/score.txt
            echo "brief outputs present."
          else
            echo "make not available; skipping build smoke test."
          fi

      - name: Enforce PR Objective line
        if: ${{ github.event_name == 'pull_request' }}
        shell: bash
        run: |
          BODY="${{ github.event.pull_request.body }}"
          echo "Checking PR body for Objective line..."
          echo "$BODY" | grep -qiE 'Class=(Core|Trunk|Branch|Leaf);[[:space:]]*.*MinimalStep=' \
            || { echo "::error::Missing Objective line. Please add:"; \
                 echo "Class=<Core|Trunk|Branch|Leaf>; Why=…; MinimalStep=…; Direction=…"; exit 1; }
