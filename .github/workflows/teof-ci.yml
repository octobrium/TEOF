name: teof-ci

on:
  push:
    paths:
      - 'seed/capsule/**'
      - 'rings/**'
      - 'branches_thick/**'
      - 'Makefile'
      - '.github/workflows/**'
  pull_request:
    paths:
      - 'seed/capsule/**'
      - 'rings/**'
      - 'branches_thick/**'
      - 'Makefile'
      - '.github/workflows/**'

permissions:
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  show-tree:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Show tree
        run: |
          if ! command -v tree >/dev/null 2>&1; then
            sudo apt-get update -y >/dev/null 2>&1 || true
            sudo apt-get install -y tree >/dev/null 2>&1 || true
          fi
          tree -a -L 3 || true

  verify:
    runs-on: ubuntu-latest
    needs: show-tree
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Ensure seed/capsule/current exists
        shell: bash
        run: |
          set -euo pipefail
          CAP_ROOT="seed/capsule"
          CUR="$CAP_ROOT/current"
          if [ ! -f "$CUR/capsule.txt" ]; then
            echo "Materializing $CUR from the latest versioned capsuleâ€¦"
            if compgen -G "$CAP_ROOT/v*/" >/dev/null; then
              latest="$(ls -1d "$CAP_ROOT"/v*/ | sort -V | tail -n1)"
              mkdir -p "$CUR"
              cp -R "$latest"* "$CUR"/
              echo "Using: $latest"
            else
              echo "::error::No versioned capsule found under $CAP_ROOT/v*/"
              exit 1
            fi
          fi

      - name: Verify capsule hashes
        shell: bash
        run: |
          set -euo pipefail
          python - <<'PY'
import os, re, json, hashlib, sys
CAP_ROOT = os.path.join('seed','capsule')
candidates = []
cur = os.path.join(CAP_ROOT,'current','hashes.json')
if os.path.isfile(cur): candidates.append(cur)
vers = []
if os.path.isdir(CAP_ROOT):
    for d in os.listdir(CAP_ROOT):
        if re.fullmatch(r'v\d+\.\d+', d) and os.path.isfile(os.path.join(CAP_ROOT,d,'hashes.json')):
            vers.append(d)
vers.sort(reverse=True)
for d in vers:
    candidates.append(os.path.join(CAP_ROOT,d,'hashes.json'))
if not candidates:
    print("Error: no hashes.json found (checked seed/capsule/current and versioned dirs)")
    sys.exit(1)
baseline = candidates[0]
base_dir = os.path.dirname(baseline)
print("Using baseline:", baseline)
with open(baseline,'r') as f:
    expected = json.load(f)
def sha256_file(p):
    h = hashlib.sha256()
    with open(p,'rb') as f:
        for chunk in iter(lambda: f.read(8192), b''):
            h.update(chunk)
    return h.hexdigest()
ok = True
for rel, exp in expected.items():
    p = os.path.join(base_dir, rel)
    if not os.path.exists(p):
        print(f"Error: missing file {p}"); ok = False; continue
    got = sha256_file(p)
    if got != exp:
        print("Error: Hash mismatch")
        print(" expected:", exp); print(" got     :", got); print(" file    :", p)
        ok = False
    else:
        print("OK", rel)
sys.exit(0 if ok else 1)
PY

      - name: Validate rings/anchors.json
        shell: bash
        run: |
          set -euo pipefail
          python - <<'PY'
import json, hashlib, os, sys, subprocess, re
P = os.path.join('rings','anchors.json')
if not os.path.exists(P):
    print("rings/anchors.json not present; skipping."); sys.exit(0)
with open(P,'r') as f: data = json.load(f)
required = ['version','policy','anchors','immutable_scope','events','releases']
missing = [k for k in required if k not in data]
if missing:
    print("Error: missing keys in rings/anchors.json:", ", ".join(missing)); sys.exit(1)
cur_bytes = open(P,'rb').read()
cur_sha   = hashlib.sha256(cur_bytes).hexdigest()
prev_sha  = None
try:
    prev_bytes = subprocess.check_output(['git','show',f'HEAD~1:{P}'], stderr=subprocess.DEVNULL)
    prev_sha = hashlib.sha256(prev_bytes).hexdigest()
except subprocess.CalledProcessError:
    pass
if prev_sha and prev_sha != cur_sha:
    last = data['events'][-1] if data['events'] else None
    if not last or last.get('prev_content_hash') != prev_sha:
        print('Error: events are not append-only (last.prev_content_hash must equal prior file SHA).'); sys.exit(1)
    else:
        print('Append-only check: OK (file changed and last.prev_content_hash matches).')
else:
    print('Append-only check: anchors.json unchanged or no previous commit.')
print(f'anchors.json sha256={cur_sha}')
CAP_ROOT = os.path.join('seed','capsule')
candidates = []
cur = os.path.join(CAP_ROOT,'current','hashes.json')
if os.path.isfile(cur): candidates.append(cur)
vers = []
if os.path.isdir(CAP_ROOT):
    for d in os.listdir(CAP_ROOT):
        if re.fullmatch(r'v\d+\.\d+', d) and os.path.isfile(os.path.join(CAP_ROOT,d,'hashes.json')):
            vers.append(d)
vers.sort(reverse=True)
for d in vers:
    candidates.append(os.path.join(CAP_ROOT,d,'hashes.json'))
if not candidates:
    print('Error: no hashes.json found for scope cross-check'); sys.exit(1)
with open(candidates[0],'r') as f:
    baseline = json.load(f)
missing = [p for p in data.get('immutable_scope', []) if p not in baseline]
if missing:
    print('Error: immutable_scope paths missing from baseline hashes.json:')
    for m in missing: print('  -', m)
    sys.exit(1)
if not data['immutable_scope']:
    print('Warning: immutable_scope is empty')
PY

      - name: Check for macOS .DS_Store
        run: |
          if git ls-files | grep -q '\.DS_Store'; then
            echo "::error::.DS_Store files committed"; exit 1
          else
            echo "No .DS_Store files found."
          fi

      - name: Build brief (smoke test)
        shell: bash
        run: |
          set -euo pipefail
          if command -v make >/dev/null 2>&1; then
            make brief
            test -f artifacts/ocers_out/latest/brief.json
            test -f artifacts/ocers_out/latest/score.txt
            echo "brief outputs present."
          else
            echo "make not available; skipping build smoke test."
          fi
