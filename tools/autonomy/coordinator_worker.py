"""Worker harness for coordinator manifests.

Loads a manifest generated by :mod:`tools.autonomy.coordinator_manager`
and either prints the assignment (dry run) or executes the recorded
commands, capturing a run receipt under `_report/agent/<agent>/<plan>/runs/`.

This is the first handshake between the coordinator layer and worker
agents so humans can donate seats with minimal manual orchestration.
"""
from __future__ import annotations

import argparse
import json
import subprocess
import time
from pathlib import Path
from typing import Any, Dict, Sequence

from tools.agent import session_guard
from tools.autonomy.shared import load_json, write_receipt_payload


ROOT = Path(__file__).resolve().parents[2]
RUNS_BASE = ROOT / "_report" / "agent"


def _utc_now() -> str:
    import datetime as dt

    return dt.datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")


def _load_manifest(path: Path) -> Dict[str, Any]:
    manifest = load_json(path)
    if not isinstance(manifest, dict):
        raise SystemExit(f"::error:: invalid manifest payload: {path}")
    for key in ("plan", "step", "commands"):
        if key not in manifest:
            raise SystemExit(f"::error:: manifest missing '{key}' field: {path}")
    return manifest


def _resolve_agent_id(explicit: str | None) -> str:
    return session_guard.resolve_agent_id(explicit)


def _runs_dir(agent_id: str, plan_id: str) -> Path:
    return RUNS_BASE / agent_id / plan_id / "runs"


def _record_run(
    *,
    manifest_path: Path,
    manifest: Dict[str, Any],
    agent_id: str,
    executed: Sequence[Dict[str, Any]],
    out_path: Path | None = None,
) -> Path:
    payload: Dict[str, Any] = {
        "version": 1,
        "generated_at": _utc_now(),
        "agent_id": agent_id,
        "manifest_path": manifest_path.as_posix(),
        "plan": manifest.get("plan"),
        "step": manifest.get("step"),
        "executed": list(executed),
    }

    if out_path is None:
        plan_id = str(manifest.get("plan", {}).get("id"))
        runs_dir = _runs_dir(agent_id, plan_id)
        runs_dir.mkdir(parents=True, exist_ok=True)
        timestamp = _utc_now().replace(":", "")
        out_path = runs_dir / f"run-{timestamp}.json"

    return write_receipt_payload(out_path, payload)


def _execute_command(cmd: Sequence[str]) -> Dict[str, Any]:
    start = time.perf_counter()
    try:
        subprocess.run(cmd, cwd=ROOT, check=True)
        status = "ok"
        exit_code = 0
    except subprocess.CalledProcessError as exc:
        status = "error"
        exit_code = exc.returncode
        duration = time.perf_counter() - start
        return {
            "cmd": list(cmd),
            "status": status,
            "exit_code": exit_code,
            "duration_seconds": duration,
        }
    duration = time.perf_counter() - start
    return {
        "cmd": list(cmd),
        "status": status,
        "exit_code": exit_code,
        "duration_seconds": duration,
    }


def parse_args(argv: Sequence[str] | None = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("manifest", type=Path, help="Path to manifest JSON produced by coordinator_manager")
    parser.add_argument("--agent-id", help="Override worker agent id (defaults to AGENT_MANIFEST.json)")
    parser.add_argument(
        "--execute",
        action="store_true",
        help="Run commands from the manifest (default: dry-run)"
    )
    parser.add_argument(
        "--allow-stale-session",
        action="store_true",
        help="Bypass session freshness guard (records override)"
    )
    parser.add_argument(
        "--receipt-out",
        type=Path,
        help="Explicit output path for the worker run receipt",
    )
    return parser.parse_args(argv)


def main(argv: Sequence[str] | None = None) -> int:
    args = parse_args(argv)
    manifest_path = args.manifest
    manifest = _load_manifest(manifest_path)
    agent_id = _resolve_agent_id(args.agent_id)

    session_guard.ensure_recent_session(
        agent_id,
        allow_stale=args.allow_stale_session,
        context="coordinator_worker",
    )

    commands = manifest.get("commands", [])
    if not isinstance(commands, list) or not commands:
        print("coordinator_worker: no commands listed; nothing to do")
        return 0

    if not args.execute:
        print("coordinator_worker: dry-run (use --execute to run commands)")
        for entry in commands:
            label = entry.get("label", "")
            desc = entry.get("description", "")
            cmd = " ".join(str(part) for part in entry.get("cmd", []))
            print(f" - {label}: {desc}\n   $ {cmd}")
        return 0

    executed: list[Dict[str, Any]] = []
    for entry in commands:
        cmd = entry.get("cmd")
        if not isinstance(cmd, list) or not cmd:
            executed.append({"cmd": cmd, "status": "skipped", "reason": "invalid command"})
            continue
        print(f"coordinator_worker: running {' '.join(cmd)}")
        result = _execute_command(cmd)
        executed.append(result)
        if result["status"] != "ok":
            print(f"coordinator_worker: command failed with exit {result['exit_code']}")
            break

    receipt = _record_run(
        manifest_path=manifest_path,
        manifest=manifest,
        agent_id=agent_id,
        executed=executed,
        out_path=args.receipt_out,
    )
    print(f"coordinator_worker: wrote {receipt.relative_to(ROOT) if receipt.is_relative_to(ROOT) else receipt}")

    last = executed[-1] if executed else {"status": "ok"}
    if last.get("status") == "ok":
        return 0
    return 1


if __name__ == "__main__":  # pragma: no cover
    raise SystemExit(main())
