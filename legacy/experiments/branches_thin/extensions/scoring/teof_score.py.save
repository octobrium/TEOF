#!/usr/bin/env python3
import argparse, json, sys, hashlib, datetime, re
from typing import Tuple, Dict

REQ = ["O","C","E","R","S"]
OPT = ["OpenQuestions"]

def now_utc_iso() -> str:
    return datetime.datetime.utcnow().replace(microsecond=0).isoformat() + "Z"

def sha256_bytes(b: bytes) -> str:
    import hashlib
    return hashlib.sha256(b).hexdigest()

def load_bytes(path: str) -> bytes:
    with open(path, "rb") as f:
        return f.read()

def try_parse_json(b: bytes) -> Tuple[bool, dict]:
    try:
        obj = json.loads(b.decode("utf-8"))
        if isinstance(obj, dict):
            return True, obj
        return False, {}
    except Exception:
        return False, {}

def parse_headed_text(s: str) -> Dict[str, str]:
    """
    Accept headed OCERS:
      O: ...
      C: ...
      E: ...
      R: ...
      S: ...
      OpenQuestions: ...
    Allows multi-line bodies until next head.
    """
    out = {}
    heads = ["O","C","E","R","S","OpenQuestions"]
    pat = re.compile(r"^([A-Za-z]+)\s*:\s*(.*)$")
    cur = None
    for raw in s.splitlines():
        line = raw.rstrip()
        m = pat.match(line.strip())
        if m and m.group(1) in heads:
            cur = m.group(1)
            out.setdefault(cur, "")
            out[cur] = m.group(2).strip()
        elif cur:
            out[cur] = (out[cur] + "\n" + line).strip()
    return out

def normalize(obj: dict) -> dict:
    clean = {}
    for k in REQ:
        if k in obj:
            clean[k] = str(obj[k]).strip()
    if "OpenQuestions" in obj:
        clean["OpenQuestions"] = str(obj["OpenQuestions"]).strip()
    return clean

# ---------- Minimal rubric helpers ----------

def word_count(s: str) -> int:
    return len(re.findall(r"\b\w+\b", s))

def has_numbers(s: str) -> bool:
    return bool(re.search(r"\d", s))

def has_year(s: str) -> bool:
    return bool(re.search(r"\b(19|20)\d{2}\b", s))

def has_link(s: str) -> bool:
    return bool(re.search(r"https?://|www\.", s))

def has_quote(s: str) -> bool:
    return '"' in s or '“' in s or '”' in s or "'" in s

def risk_markers(s: str) -> int:
    # simple set capturing uncertainty/risk language
    keys = [
        r"\brisk\b", r"\bfailure\b", r"\buncertain", r"\bunknown\b",
        r"\bassumption\b", r"\bbias\b", r"\blimitation\b", r"\bconfound",
        r"\bedge case\b", r"\btrade[- ]?off\b", r"\bmitigat", r"\bhazard\b"
    ]
    return sum(1 for k in keys if re.search(k, s, re.I))

def step_markers(s: str) -> int:
    # actionability: numbered or bulleted lines + imperatives
    lines = [ln.strip() for ln in s.splitlines() if ln.strip()]
    list_like = sum(1 for ln in lines if re.match(r"^(\d+\.|-|\*)\s+", ln))
    imperatives = len(re.findall(r"\b(ensure|verify|run|apply|compare|log|document|measure|test|rollback|dry[- ]?run|revert|deploy|ship|analyze|check)\b", s, re.I))
    return list_like + imperatives

# ---------- Rubric (0–20 each) ----------

def score_O(text: str) -> Tuple[int, str]:
    n = word_count(text)
    # Ideal concise window: 25–80 words
    if n == 0: return 0, "O empty"
    if n < 10: return 8, "O too short"
    if n > 120: return 10, "O too long"
    # within window, scale toward 20
    if 25 <= n <= 80: return 18, "O concise"
    return 16, "O acceptable"

def score_C(text: str) -> Tuple[int, str]:
    n = word_count(text)
    if n == 0: return 0, "C empty"
    if n < 15: return 10, "C too short"
    if n > 160: return 12, "C too long"
    # light structure signal: paragraphs or separators
    has_breaks = "\n" in text or ";" in text
    return (18 if has_breaks else 16), ("C structured" if has_breaks else "C ok")

def score_E(text: str) -> Tuple[int, str]:
    if not text.strip(): return 0, "E empty"
    pts = 10
    if has_numbers(text): pts += 3
    if has_year(text):    pts += 3
    if has_link(text):    pts += 2
    if has_quote(text):   pts += 2
    pts = min(20, pts)
    note_bits = []
    if has_numbers(text): note_bits.append("numbers")
    if has_year(text):    note_bits.append("year")
    if has_link(text):    note_bits.append("link")
    if has_quote(text):   note_bits.append("quote")
    note = "E specificity: " + (", ".join(note_bits) if note_bits else "low")
    return pts, note

def score_R(text: str) -> Tuple[int, str]:
    if not text.strip(): return 0, "R empty"
    m = risk_markers(text)
    if m == 0: return 10, "R weak"
    if m == 1: return 14, "R ok"
    if m == 2: return 17, "R good"
    return 20, "R strong"

def score_S(text: str) -> Tuple[int, str]:
    if not text.strip(): return 0, "S empty"
    m = step_markers(text)
    if m == 0:
        # still grant minimal if at least one clear sentence
        return 12, "S generic"
    if m == 1: return 16, "S ok"
    if m == 2: return 18, "S good"
    return 20, "S actionable"

# ---------- Main ----------

def main():
    ap = argparse.ArgumentParser(description="TEOF Scoring System (minimal v0.1)")
    ap.add_argument("--input", required=True, help="Path to OCERS output (JSON or headed text)")
    ap.add_argument("--commit", required=True, help="Commit short SHA or identifier")
    ap.add_argument("--receipt-json", default=None, help="Optional: write machine-readable score JSON")
    args = ap.parse_args()

    ts = now_utc_iso()

    try:
        raw = load_bytes(args.input)
    except Exception as e:
        print(f"FAIL: cannot read input ({e})")
        sys.exit(3)

    is_json, j = try_parse_json(raw)
    if is_json:
        ocers = normalize(j)
    else:
        ocers = normalize(parse_headed_text(raw.decode("utf-8", errors="replace")))

    # Minimal guard: require fields exist (scorer itself doesn’t enforce emptiness beyond rubric)
    for k in REQ:
        ocers.setdefault(k, "")

    so, no = score_O(ocers["O"])
    sc, nc = score_C(ocers["C"])
    se, ne = score_E(ocers["E"])
    sr, nr = score_R(ocers["R"])
    ss, ns = score_S(ocers["S"])

    total = so + sc + se + sr + ss
    notes = "; ".join([no, nc, ne, nr, ns])

    line = (
        f"TEOF-SCORE v0.1 | score={total}/100 | "
        f"O={so} C={sc} E={se} R={sr} S={ss} | "
        f"commit={args.commit} | ocers_json={1 if is_json else 0} | utc={ts} | notes=\"{notes}\""
    )
    print(line)

    if args.receipt_json:
        try:
            with open(args.receipt_json, "w") as f:
                json.dump({
                    "score": total,
                    "subs": {"O": so, "C": sc, "E": se, "R": sr, "S": ss},
                    "notes": {"O": no, "C": nc, "E": ne, "R": nr, "S": ns},
                    "commit": args.commit,
                    "ocers_json": 1 if is_json else 0,
                    "out_sha256": sha256_bytes(raw),
                    "utc": ts
                }, f, indent=2)
        except Exception as e:
            print(f"WARN: could not write receipt JSON ({e})", file=sys.stderr)

    sys.exit(0)

if __name__ == "__main__":
    main()

python3 scoring/teof_score.py \
  --input validator/sample_outputs/ocers_ok.json \
  --commit abc123


