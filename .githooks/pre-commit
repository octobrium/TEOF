#!/usr/bin/env bash
# TEOF pre-commit: keep governance/anchors.json append-only proof in sync.
# Non-blocking: auto-fixes prev_content_hash and never fails a commit.

set -euo pipefail

P="governance/anchors.json"
[ -f "$P" ] || exit 0

# Require jq; if missing, skip quietly (CI will still enforce).
if ! command -v jq >/dev/null 2>&1; then
  echo "pre-commit: jq not found; skipping anchors auto-fix"
  exit 0
fi

# Portable SHA256 of stdin.
sha256_stdin() {
  if command -v shasum >/dev/null 2>&1; then
    shasum -a 256 | awk '{print $1}'
  elif command -v sha256sum >/dev/null 2>&1; then
    sha256sum | awk '{print $1}'
  elif command -v python3 >/dev/null 2>&1; then
    python3 - <<'PY'
import sys, hashlib
print(hashlib.sha256(sys.stdin.buffer.read()).hexdigest())
PY
  elif command -v python >/dev/null 2>&1; then
    python - <<'PY'
import sys, hashlib
data = getattr(sys.stdin, "buffer", sys.stdin).read()
print(hashlib.sha256(data).hexdigest())
PY
  elif command -v openssl >/dev/null 2>&1; then
    # outputs: "SHA256(stdin)= <hash>"
    openssl dgst -sha256 | awk '{print $2}'
  else
    echo ""
  fi
}

# Previous commit that CHANGED this file (not necessarily HEAD~1).
prev="$(git rev-list -n 2 HEAD -- "$P" | tail -n1 || true)"
[ -z "$prev" ] && exit 0  # first write; nothing to compare

prev_sha="$(git show "${prev}:${P}" | sha256_stdin)"
[ -z "$prev_sha" ] && { echo "pre-commit: no sha256 tool; skipping anchors auto-fix"; exit 0; }

# Recorded value (empty if field missing).
rec="$(jq -r '.events[-1].prev_content_hash // ""' "$P" 2>/dev/null || echo "")"

if [ -n "$rec" ] && [ "$rec" != "$prev_sha" ]; then
  tmp="${P}.tmp"
  jq --arg h "$prev_sha" '.events[-1].prev_content_hash=$h' "$P" > "$tmp" && mv "$tmp" "$P"
  git add "$P"
  echo "pre-commit: updated $P prev_content_hash -> $prev_sha"
fi

exit 0
